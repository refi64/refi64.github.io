<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/"><channel><title>BlockByte</title><link>http://kirbyfan64.github.io/</link><description>Random programming tidbits/tutorials</description><language>en</language><lastBuildDate>Sun, 17 May 2015 18:15:40 GMT</lastBuildDate><generator>http://getnikola.com/</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Functional programming isn't the answer to all problems (and neither is OOP)</title><link>http://kirbyfan64.github.io/posts/functional-programming-isnt-the-answer-to-all-problems-and-neither-is-oop.html</link><dc:creator>Ryan Gonzalez</dc:creator><description>&lt;p&gt;I like functional programming. Being a big fan of Python and C++, it took a while to get used to functional languages like Haskell and Felix (my personal favorite FP language). I started out with &lt;em&gt;Learn You a Haskell for Great Good!&lt;/em&gt; and then started toying with OCaml and Felix. I stuck with Felix and ditched OCaml because I just didn't like it.&lt;/p&gt;
&lt;p&gt;However, it isn't the solution to the world's issues. People used to think OOP was the solution to everything. They started shoving every freaking thing on earth in a class and adding useless methods. Then they realized that Java sucked. Now, everyone seems to think that FP is going to take over the world. I disagree. Why?&lt;/p&gt;
&lt;div class="section" id="certain-programs-are-easier-to-extend-with-oop"&gt;
&lt;h2&gt;Certain programs are easier to extend with OOP&lt;/h2&gt;
&lt;p&gt;I &lt;em&gt;love&lt;/em&gt; Norman Ramsey's Stack Overflow answers because they're from a functional programming advocate who knows that it's not the solution to all issues. Take his answer to &lt;a class="reference external" href="http://stackoverflow.com/a/2079678/2097780"&gt;Functional programming vs Object Oriented programming&lt;/a&gt;. Basically, OOP languages are good when the operations on things stay the same, and you just add new things. Functional languages are good when the things stay the same and you're constantly adding new operations.&lt;/p&gt;
&lt;p&gt;It has bitten me several times in functional languages before when I forgot to update a pattern match someone to make up for a new field in my algebraic data type. Same thing for OOP: I've had problems when adding new algorithms/transformations on OOP objects and end up forgetting something somewhere, only to get a 200-template error message about instantiating some ABC somewhere (C++) or a &lt;tt class="docutils literal"&gt;NotImplementedError&lt;/tt&gt; (Python). Neither paradigm solves both issues.&lt;/p&gt;
&lt;p&gt;IMO, build systems are good with OOP. You tend to add support for, say, extra C++ compilers more than you add a new compilation command (how many different ways to do the same thing are there?).&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="it-can-be-hard-to-predict-performance"&gt;
&lt;h2&gt;It can be hard to predict performance&lt;/h2&gt;
&lt;p&gt;This is more an issue with lazy languages (e.g. Haskell) and tracing JITs (like PyPy) than strict languages (like C++, Felix, and ML).&lt;/p&gt;
&lt;p&gt;Basically, it's hard to predict how a program will perform. This innocent function:&lt;/p&gt;
&lt;pre class="code haskell literal-block"&gt;
&lt;span class="nf"&gt;f&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;foldl1&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;will explode if given a list too long; the stack will be exhausted. Or it will just take forever. You need to use &lt;tt class="docutils literal"&gt;foldl1'&lt;/tt&gt; in that case, which is strict.&lt;/p&gt;
&lt;p&gt;In imperative programming, this isn't even a problem:&lt;/p&gt;
&lt;pre class="code c++ literal-block"&gt;
&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10000000&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;accumulate&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;begin&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;plus&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;{})&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;I had this code in all:&lt;/p&gt;
&lt;p&gt;Haskell:&lt;/p&gt;
&lt;pre class="code haskell literal-block"&gt;
&lt;span class="nf"&gt;f&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;foldl1&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="nf"&gt;main&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;print&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="n"&gt;replicate&lt;/span&gt; &lt;span class="mi"&gt;10000000&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;/pre&gt;
&lt;div class="note"&gt;
&lt;p class="first admonition-title"&gt;Note&lt;/p&gt;
&lt;p class="last"&gt;I know about &lt;tt class="docutils literal"&gt;sum&lt;/tt&gt;, but using it distracts from the point of this whole post.&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;C++:&lt;/p&gt;
&lt;pre class="code c++ literal-block"&gt;
&lt;span class="cp"&gt;#include &amp;lt;functional&amp;gt;
#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;iostream&amp;gt;
&lt;/span&gt;
&lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="k"&gt;namespace&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10000000&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;accumulate&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;begin&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;plus&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;The Haskell version gives a stack overflow after 1.7 seconds. Changing &lt;tt class="docutils literal"&gt;foldl1&lt;/tt&gt; to &lt;tt class="docutils literal"&gt;foldl1'&lt;/tt&gt; fixes it, but it still takes 0.184s. C++ version? 0.022s.&lt;/p&gt;
&lt;p&gt;Now, I'm not saying that Haskell is slow; it can actually be quite fast. I'm just saying that it can be hard to predict performance, where your stack will explode, or where you can blow threw several gigs of RAM.&lt;/p&gt;
&lt;p&gt;It's worth saying again that this is only really bad for lazy languages, so Felix and OCaml shouldn't suffer from it as badly. Rust also doesn't suffer from it; the program I wrote took 0.04s.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="it-s-not-magic"&gt;
&lt;h2&gt;It's not magic&lt;/h2&gt;
&lt;p&gt;I keep saying it: it's not going to make everyone happy, create world peace, make Windows actually work, and make you 6 meals a day. I like FP for certain situations. Haskell is fun (and makes you feel smart!), Felix is just awesome, and Rust is neat.&lt;/p&gt;
&lt;p&gt;Same thing goes for OOP. I'm not going to try to tackle those issues because 20k blog posts already have.&lt;/p&gt;
&lt;p&gt;I'm not bashing FP; I'm just saying it isn't perfect. Everyone loves it right now. In 20 years, someone's going to find something wrong. Then everyone's going to hate it and start using &lt;a class="reference external" href="http://evincarofautumn.blogspot.com/2012/02/why-concatenative-programming-matters.html"&gt;concatenative programming&lt;/a&gt;. Until everyone realizes it sucks and starts using the true source of happiness: &lt;a class="reference external" href="http://en.wikipedia.org/wiki/Brainfuck"&gt;tape-based programming&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="what-about-mixing-them"&gt;
&lt;h2&gt;What about mixing them?&lt;/h2&gt;
&lt;p&gt;This is hard. In the end, one is always going to be better supported than the other.&lt;/p&gt;
&lt;p&gt;For instance, you can write FP-like programs in Python. But Python has a rich object system, not a pattern-matching system. Therefore, Python seems to lean towards OOP. Same thing for C++.&lt;/p&gt;
&lt;p&gt;Felix has objects, but they end up compiling down to closures. In reality, Felix leans towards FP.&lt;/p&gt;
&lt;p&gt;Scala ends up leaning towards OOP, if not just because most of the Java libraries you'll end up using from Scala use classes.&lt;/p&gt;
&lt;p&gt;Some languages that claim that they use FP, like K, seem to be more procedural in nature, too.&lt;/p&gt;
&lt;p&gt;Again, there's no perfect answer. If programming was a solved problem, I'm not sure what would happen, because we haven't reached that point, and we probably never will.&lt;/p&gt;
&lt;p&gt;Also, I'm not saying that moving forward like this is bad. Imagine what would happen if we were still writing everything in COBOL and Fortran!&lt;/p&gt;
&lt;p&gt;But it's just not all cut out. Trying to mix them perfectly doesn't work out, either...&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="https://youtu.be/kCHVW65YLJs?t=36s"&gt;IT'S NO USE!!!!&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;</description><guid>http://kirbyfan64.github.io/posts/functional-programming-isnt-the-answer-to-all-problems-and-neither-is-oop.html</guid><pubDate>Sun, 17 May 2015 21:59:00 GMT</pubDate></item><item><title>The top 5 programming languages you've never heard of (part 2)</title><link>http://kirbyfan64.github.io/posts/the-top-5-programming-languages-youve-never-heard-of-part-2.html</link><dc:creator>Ryan Gonzalez</dc:creator><description>&lt;p&gt;Yesterday, I wrote a post about &lt;a class="reference external" href="http://kirbyfan64.github.io/posts/the-top-5-programming-languages-youve-never-heard-of.html"&gt;the top 5 programming languages you've never heard of&lt;/a&gt;. Well, since it was kind of short (I didn't have too much time to write), I'm going to put a little more info here.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://kirbyfan64.github.io/posts/the-top-5-programming-languages-youve-never-heard-of-part-2.html"&gt;Read more…&lt;/a&gt; (6 min remaining to read)&lt;/p&gt;</description><category>compilers</category><category>felix</category><category>k</category><category>languages</category><category>myrddin</category><category>nim</category><category>objeck</category><category>programming</category><guid>http://kirbyfan64.github.io/posts/the-top-5-programming-languages-youve-never-heard-of-part-2.html</guid><pubDate>Sun, 08 Mar 2015 22:04:17 GMT</pubDate></item><item><title>The top 5 programming Languages you've never heard of</title><link>http://kirbyfan64.github.io/posts/the-top-5-programming-languages-youve-never-heard-of.html</link><dc:creator>Ryan Gonzalez</dc:creator><description>&lt;p&gt;Lately, there's been a large surge in new programming languages as projects such as &lt;a class="reference external" href="http://www.rust-lang.org/"&gt;Rust&lt;/a&gt; have been taking the spotlight and showing lots of promise. However, there are some programming languages few have heard of that deserve to be more popular. Here's a brief listing of some of my favorite languages that aren't common sights.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://kirbyfan64.github.io/posts/the-top-5-programming-languages-youve-never-heard-of.html"&gt;Read more…&lt;/a&gt; (2 min remaining to read)&lt;/p&gt;</description><category>compilers</category><category>felix</category><category>k</category><category>languages</category><category>myrddin</category><category>nim</category><category>objeck</category><category>programming</category><guid>http://kirbyfan64.github.io/posts/the-top-5-programming-languages-youve-never-heard-of.html</guid><pubDate>Sun, 08 Mar 2015 00:56:29 GMT</pubDate></item><item><title>Using AppVeyor to distribute Python wheels</title><link>http://kirbyfan64.github.io/posts/using-appveyor-to-distribute-python-wheels.html</link><dc:creator>Ryan Gonzalez</dc:creator><description>&lt;p&gt;&lt;a class="reference external" href="http://wheel.readthedocs.org/en/latest/"&gt;Wheels&lt;/a&gt; are the future of distribution. No more messy broken &lt;cite&gt;setup.py&lt;/cite&gt; scripts or need for a compiler to build C extensions! Of course, this has a glaring issue: a Linux user can't build Wheels of their C extension for Windows. Unless, of course, you use &lt;a class="reference external" href="https://travis-ci.org/"&gt;Travis CI&lt;/a&gt;, install the MinGW compilers, define the compiler variables, etc. However, there is an easier way: &lt;a class="reference external" href="http://kirbyfan64.github.io/posts/www.appveyor.com"&gt;AppVeyor&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://kirbyfan64.github.io/posts/using-appveyor-to-distribute-python-wheels.html"&gt;Read more…&lt;/a&gt; (1 min remaining to read)&lt;/p&gt;</description><category>appveyor</category><category>ci</category><category>python</category><category>wheels</category><guid>http://kirbyfan64.github.io/posts/using-appveyor-to-distribute-python-wheels.html</guid><pubDate>Sun, 21 Sep 2014 22:02:14 GMT</pubDate></item><item><title>Overloading functions with the C preprocessor</title><link>http://kirbyfan64.github.io/posts/overloading-functions-with-the-c-preprocessor.html</link><dc:creator>Ryan Gonzalez</dc:creator><description>&lt;p&gt;Let's have an imaginary scenario: you're trying to make a library that has a special function, &lt;em&gt;myfunc&lt;/em&gt;. Now, this functions needs to have two possible ways to invoke it. One way takes one int parameter, the other takes two. Here's how you might do that in C++:&lt;/p&gt;
&lt;pre class="code c++ literal-block"&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;myfunc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;myfunc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;C doesn't have a way to do this. You'll often see code like this:&lt;/p&gt;
&lt;pre class="code c literal-block"&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;myfunc_1&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;myfunc_2&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;However, this &lt;em&gt;can&lt;/em&gt; be implemented, albeit in a slightly convoluted way using a very controversial tool: the C preprocessor.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://kirbyfan64.github.io/posts/overloading-functions-with-the-c-preprocessor.html"&gt;Read more…&lt;/a&gt; (2 min remaining to read)&lt;/p&gt;</description><category>c preprocessor hack</category><guid>http://kirbyfan64.github.io/posts/overloading-functions-with-the-c-preprocessor.html</guid><pubDate>Tue, 16 Sep 2014 01:42:34 GMT</pubDate></item><item><title>Welcome!</title><link>http://kirbyfan64.github.io/posts/welcome.html</link><dc:creator>Ryan Gonzalez</dc:creator><description>&lt;p&gt;First post!&lt;/p&gt;
&lt;p&gt;This website is my first ever web page. It's written using the excellent &lt;a class="reference external" href="http://getnikola.com"&gt;Nikola&lt;/a&gt; and reStructuredText. The majority of its content is going to revolve around programming: tutorials, experiments, and lots and lots of rants. :)&lt;/p&gt;
&lt;p&gt;Have fun browsing!&lt;/p&gt;</description><guid>http://kirbyfan64.github.io/posts/welcome.html</guid><pubDate>Wed, 10 Sep 2014 23:02:45 GMT</pubDate></item></channel></rss>