<!DOCTYPE html>
<html prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article# " lang="en">
    <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>An idea for concise, checked error handling in imperative languages | BlockByte</title>

    
            <link href="../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">

    
            <link rel="alternate" type="application/rss+xml" title="RSS" href="../rss.xml">

      <link rel="canonical" href="http://kirbyfan64.github.io/posts/an-idea-for-concise-checked-error-handling-in-imperative-languages.html">



    
        <!--[if lt IE 9]><script src="/assets/js/html5.js"></script><![endif]-->

    


    

    <meta name="author" content="Ryan Gonzalez">
    
        <meta name="og:title" content="An idea for concise, checked error handling in imperative languages">
        <meta name="og:url" content="http://kirbyfan64.github.io/posts/an-idea-for-concise-checked-error-handling-in-imperative-languages.html">
            <meta name="og:description" content="Yes, the post title sucks. However, I can't think of anything better...
This is an idea I've had for a while on an error handling model that tries to
combine safe, checked code with the conciseness of">
        <meta name="og:site_name" content="BlockByte">
        <meta name="og:type" content="article">

    

    



</head>
<body>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-fixed-top" role="navigation">
    <div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="http://kirbyfan64.github.io/">

                <span id="blog-title">BlockByte</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse navbar-ex1-collapse">
            <ul class="nav navbar-nav">
                
                <li>
<a href="../archive.html">Archive</a>
                </li>
<li>
<a href="../categories/index.html">Tags</a>
                </li>
<li>
<a href="../rss.xml">RSS feed</a>
            </li>
<li class="dropdown">
<a href="#" class="dropdown-toggle" data-toggle="dropdown">Randomness<b class="caret"></b></a>
            <ul class="dropdown-menu">
                    <li>
<a href="../pages/randomness.html">Index</a>
                    </li>
<li>
<a href="../pages/katex.html">KaTeX Previewer</a>
            </li>
</ul>

                
            </li>
</ul>

            <ul class="nav navbar-nav navbar-right">
                
                
                    
    <li>
    <a href="an-idea-for-concise-checked-error-handling-in-imperative-languages.rst" id="sourcelink">Source</a>
    </li>

                
            </ul>
        </div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav>

<!-- End of Menubar -->

<div class="container">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            
<article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article">
    
    <header>
        
    <h1 class="p-name entry-title" itemprop="headline name"><a href="#" class="u-url">An idea for concise, checked error handling in imperative languages</a></h1>

        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn">Ryan Gonzalez</span></p>
            <p class="dateline"><a href="#" rel="bookmark"><time class="published dt-published" datetime="2016-03-20T16:34:44-05:00" itemprop="datePublished" title="Publication date">2016-03-20 16:34</time></a></p>
                <p class="commentline">
        
    <a href="an-idea-for-concise-checked-error-handling-in-imperative-languages.html#disqus_thread" data-disqus-identifier="cache/posts/an-idea-for-concise-checked-error-handling-in-imperative-languages.html">Comments</a>


            
        </p>
<p class="sourceline"><a href="an-idea-for-concise-checked-error-handling-in-imperative-languages.rst" id="sourcelink">Source</a></p>

        </div>
        

    </header>

    <div class="e-content entry-content" itemprop="articleBody text">
    <p>Yes, the post title sucks. However, I can't think of anything better...</p>
<p>This is an idea I've had for a while on an error handling model that tries to
combine safe, checked code with the conciseness of unchecked exceptions. It's
somewhat of a "rough draft", so to speak, and the syntax I'm using is just an
example.</p>
<!-- TEASER_END -->
<div class="section" id="current-error-handling-strategies">
<h2>Current error handling strategies</h2>
<p>There are a lot of models that currently exist for error handling. Among them are
exceptions (C++, Python), checked exceptions (Java, Nim), multiple return values
(Elixir, Go), union types/ADTs (Haskell, Felix, Rust, OCaml [I think...]), and a
mix of them all (C). However, they all have some issues that cause religious wars
between their supporters:</p>
<ul class="simple">
<li>Exceptions are completely unchecked. Goodness knows whether or not you are
handling all the cases. Often, a function will throw an exception that you
didn't even know threw <em>anything</em>.</li>
<li>Checked exceptions can be either painful or breakable. When a compiler
implements them with 100% precision, then you can run into issues with
callbacks. Does <cite>my_function_that_takes_a_callback(callback)</cite> not throw
anything, but <cite>callback</cite> can? Too bad. When they're breakable, then that brings
us back to the first problem.</li>
<li>Multiple return values can be a bit verbose at times. Go code tends to be
littered with <cite>if err != nil</cite> calls. Elixir code is MUCH better in this regard,
but the errors a function can return are still somewhat unchecked. Since they
use strings, you can't easily check what error exactly occurred. (Note that
Elixir actually just uses a single return value that's a tuple, like
<tt class="docutils literal">{:ok, result}</tt> or <tt class="docutils literal">{:error, error_message}</tt>.)</li>
<li>Union types seem to combine the best of them all. They are completely explicit
but work with callbacks (since errors are actually values) and can be more
concise than multiple return values (like Haskell does it). Unfortunately, they
can also combine the <em>worst</em> from each method:<ul>
<li>In Haskell, functions that return <cite>Maybe T</cite> don't quite say what error they
returned, which was a problem with multiple return values.</li>
<li>In other languages, such as Felix, they can be quite a bit verbose. Rust is
better, but things can still get a bit ugly at times.</li>
<li>If you ever have to deal with multiple different types of errors being thrown
at once...tough luck.</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="imperative-monads">
<h2>Imperative monads</h2>
<p>Now, I'm going to present an idea that tries to combine the best of these WITHOUT
the worst. Here it goes:</p>
<p>Let's take a language with type inference. Say Crystal. Now, we'll add a new type
<tt class="docutils literal"><span class="pre">T![a,b,c...]</span></tt>, which means <em>T or any of the error types a, b, c, ...</em>.</p>
<p>When a function wants an error to occur, it would do this:</p>
<pre class="code ruby literal-block">
<span class="k">def</span> <span class="nf">myfunc</span><span class="p">(</span><span class="n">a</span> <span class="p">:</span> <span class="no">Int32</span><span class="p">)</span>
  <span class="k">raise</span> <span class="no">MyErrorType</span><span class="o">.</span><span class="n">new</span> <span class="k">if</span> <span class="n">a</span> <span class="o">==</span> <span class="mi">0</span>
  <span class="k">return</span> <span class="n">a</span>
<span class="k">end</span>
</pre>
<p>This <em>appears</em> to be just a normal exception throw, but it really isn't. <tt class="docutils literal">raise</tt>
here would actually just be returning <tt class="docutils literal">MyErrorType.new</tt>. This code would roughly
be the exact same thing semantically as:</p>
<pre class="code ruby literal-block">
<span class="k">def</span> <span class="nf">myfunc</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
  <span class="c1"># Using Haskell Left/Right naming.</span>
  <span class="k">return</span> <span class="no">Left</span><span class="o">.</span><span class="n">new</span> <span class="s2">"invalid number </span><span class="si">#{</span><span class="n">a</span><span class="si">}</span><span class="s2">"</span> <span class="k">if</span> <span class="n">a</span> <span class="o">==</span> <span class="mi">0</span>
  <span class="k">return</span> <span class="no">Right</span><span class="o">.</span><span class="n">new</span> <span class="n">a</span>
<span class="k">end</span>
</pre>
<p>In short, it's just union types, but more concise. Because of Crystal's type
inference, this would make <tt class="docutils literal">myfunc</tt>'s return type <tt class="docutils literal"><span class="pre">Int32![MyErrorType]</span></tt>.</p>
<p>The cool part comes with handling the errors. If this were fully union types, the
code may be something like (Crystal doesn't actually have pattern matching like I
show; I'm just improvising):</p>
<pre class="code ruby literal-block">
<span class="k">def</span> <span class="nf">myotherfunc</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
  <span class="k">case</span> <span class="n">myfunc</span> <span class="n">a</span>
  <span class="k">when</span> <span class="no">Left</span> <span class="n">error</span>
    <span class="nb">puts</span> <span class="s2">"An error occurred: </span><span class="si">#{</span><span class="n">error</span><span class="si">}</span><span class="s2">"</span>
  <span class="k">when</span> <span class="no">Right</span> <span class="n">result</span>
    <span class="nb">puts</span> <span class="s2">"Function returned: </span><span class="si">#{</span><span class="n">value</span><span class="si">}</span><span class="s2">"</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre>
<p>However, this is where things go a completely different route:</p>
<pre class="code ruby literal-block">
<span class="k">def</span> <span class="nf">myotherfunc</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
  <span class="n">try</span>
    <span class="n">myfunc</span> <span class="n">a</span>
  <span class="n">except</span> <span class="no">MyErrorType</span> <span class="n">as</span> <span class="n">ex</span>
    <span class="nb">puts</span> <span class="s2">"An error occurred: </span><span class="si">#{</span><span class="n">ex</span><span class="o">.</span><span class="n">message</span><span class="si">}</span><span class="s2">"</span>
  <span class="k">else</span> <span class="n">value</span>
    <span class="nb">puts</span> <span class="s2">"Function returned: </span><span class="si">#{</span><span class="n">value</span><span class="si">}</span><span class="s2">"</span>
<span class="k">end</span>
</pre>
<p>"But wait," you say, "how is this different from exceptions!?" Well, this <tt class="docutils literal">try</tt>
is not at all like a normal <tt class="docutils literal">try</tt>.</p>
<p>Instead, the body of the <tt class="docutils literal">try</tt> statement MUST be an expression that returns
<tt class="docutils literal"><span class="pre">T![E...]</span></tt>. If any <tt class="docutils literal">E</tt> is returned, then it goes to the appropriate <tt class="docutils literal">except</tt>
block. If no error occurred, then it jumps to the <tt class="docutils literal">else</tt> block, giving it the
value of type <tt class="docutils literal">T</tt>.</p>
<p>The key difference here is that you can't just do something like
<tt class="docutils literal">1 + myfunc(1)</tt>; an error would occur since you're trying to add 1 (of type
<tt class="docutils literal">Int32</tt>) to <tt class="docutils literal">myfunc(1)</tt> (of type <tt class="docutils literal"><span class="pre">Int32![MyErrorType]</span></tt>).</p>
<p>Another major difference is what happens if an <tt class="docutils literal">except</tt> block doesn't cover
a possible error. For instance, if <tt class="docutils literal">myfunc</tt> were changed to:</p>
<pre class="code ruby literal-block">
<span class="k">def</span> <span class="nf">myfunc</span><span class="p">(</span><span class="n">a</span> <span class="p">:</span> <span class="no">Int32</span><span class="p">)</span>
  <span class="k">raise</span> <span class="no">MyErrorType</span><span class="o">.</span><span class="n">new</span> <span class="k">if</span> <span class="n">a</span> <span class="o">==</span> <span class="mi">0</span>
  <span class="c1"># A new error:</span>
  <span class="k">raise</span> <span class="no">MyOtherErrorType</span><span class="o">.</span><span class="n">new</span> <span class="k">if</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="mi">0</span>
<span class="k">end</span>
</pre>
<p>What would happen to <tt class="docutils literal">myotherfunc</tt>? It wouldn't compile!</p>
<p>If there is would possibly be no matching <tt class="docutils literal">except</tt> block, then the compiler
would treat <tt class="docutils literal">myotherfunc</tt> as if it said:</p>
<pre class="code ruby literal-block">
<span class="k">def</span> <span class="nf">myotherfunc</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
  <span class="n">try</span>
    <span class="n">myfunc</span> <span class="n">a</span>
  <span class="n">except</span> <span class="no">MyErrorType</span> <span class="n">as</span> <span class="n">ex</span>
    <span class="nb">puts</span> <span class="s2">"An error occurred: </span><span class="si">#{</span><span class="n">ex</span><span class="o">.</span><span class="n">message</span><span class="si">}</span><span class="s2">"</span>
  <span class="c1"># Inserted by the compiler</span>
  <span class="n">except</span> <span class="no">MyOtherErrorType</span> <span class="n">as</span> <span class="n">ex</span>
    <span class="k">raise</span> <span class="n">ex</span> <span class="c1"># Re-raise the error</span>
  <span class="k">else</span> <span class="n">value</span>
    <span class="nb">puts</span> <span class="s2">"Function returned: </span><span class="si">#{</span><span class="n">value</span><span class="si">}</span><span class="s2">"</span>
<span class="k">end</span>
</pre>
<p>Now <tt class="docutils literal">myotherfunc</tt> is inferred to return <tt class="docutils literal"><span class="pre">Int32![MyOtherErrorType]</span></tt>. In order
to fix it, you can just do:</p>
<pre class="code ruby literal-block">
<span class="k">def</span> <span class="nf">myotherfunc</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
  <span class="n">try</span>
    <span class="n">myfunc</span> <span class="n">a</span>
  <span class="c1"># Take either type of error.</span>
  <span class="n">except</span> <span class="no">MyErrorType</span> <span class="o">|</span> <span class="no">MyOtherErrorType</span> <span class="n">as</span> <span class="n">ex</span>
    <span class="nb">puts</span> <span class="s2">"An error occurred: </span><span class="si">#{</span><span class="n">ex</span><span class="o">.</span><span class="n">message</span><span class="si">}</span><span class="s2">"</span>
  <span class="k">else</span> <span class="n">value</span>
    <span class="nb">puts</span> <span class="s2">"Function returned: </span><span class="si">#{</span><span class="n">value</span><span class="si">}</span><span class="s2">"</span>
<span class="k">end</span>
</pre>
<p>You could also omit any <tt class="docutils literal">except</tt> clause. For example:</p>
<pre class="code ruby literal-block">
<span class="k">def</span> <span class="nf">myotherfunc</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
  <span class="n">try</span>
    <span class="n">myfunc</span> <span class="n">a</span>
  <span class="c1"># No except clauses</span>
  <span class="k">else</span> <span class="n">value</span>
    <span class="nb">puts</span> <span class="s2">"Function returned: </span><span class="si">#{</span><span class="n">value</span><span class="si">}</span><span class="s2">"</span>
<span class="k">end</span>
</pre>
<p>This would be equivalent to:</p>
<pre class="code ruby literal-block">
<span class="k">def</span> <span class="nf">myotherfunc</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
  <span class="n">try</span>
    <span class="n">myfunc</span> <span class="n">a</span>
  <span class="c1"># Inserted by compiler.</span>
  <span class="n">except</span> <span class="no">MyErrorType</span> <span class="o">|</span> <span class="no">MyOtherErrorType</span> <span class="n">as</span> <span class="n">ex</span>
    <span class="k">raise</span> <span class="n">ex</span>
  <span class="k">else</span> <span class="n">value</span>
    <span class="nb">puts</span> <span class="s2">"Function returned: </span><span class="si">#{</span><span class="n">value</span><span class="si">}</span><span class="s2">"</span>
<span class="k">end</span>
</pre>
<p>In addition, this can be an expression. If an error occurs, the function instantly
returns; otherwise, the value of the <tt class="docutils literal">else</tt> block is returned:</p>
<pre class="code ruby literal-block">
<span class="k">def</span> <span class="nf">myotherfunc</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
  <span class="n">result</span> <span class="o">=</span> <span class="n">try</span>
    <span class="n">myfunc</span> <span class="n">a</span>
  <span class="n">except</span> <span class="no">MyErrorType</span> <span class="o">|</span> <span class="no">MyOtherErrorType</span> <span class="n">as</span> <span class="n">ex</span>
    <span class="nb">puts</span> <span class="s2">"An error occurred: </span><span class="si">#{</span><span class="n">ex</span><span class="o">.</span><span class="n">message</span><span class="si">}</span><span class="s2">"</span>
  <span class="k">else</span> <span class="n">value</span>
    <span class="nb">puts</span> <span class="s2">"Function returned: </span><span class="si">#{</span><span class="n">value</span><span class="si">}</span><span class="s2">"</span>
    <span class="n">value</span> <span class="o">+</span> <span class="mi">1</span>
  <span class="nb">puts</span> <span class="n">result</span>
<span class="k">end</span>
</pre>
<p>If the <tt class="docutils literal">else</tt> block is ommitted, then the non-error value is returned:</p>
<pre class="code ruby literal-block">
<span class="k">def</span> <span class="nf">myotherfunc</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
  <span class="n">result</span> <span class="o">=</span> <span class="n">try</span>
    <span class="n">myfunc</span> <span class="n">a</span>
  <span class="n">except</span> <span class="no">MyErrorType</span> <span class="o">|</span> <span class="no">MyOtherErrorType</span> <span class="n">as</span> <span class="n">ex</span>
    <span class="nb">puts</span> <span class="s2">"An error occurred: </span><span class="si">#{</span><span class="n">ex</span><span class="o">.</span><span class="n">message</span><span class="si">}</span><span class="s2">"</span>
  <span class="c1"># No else block; same thing as putting:</span>
  <span class="c1"># else value</span>
  <span class="c1">#   value</span>
  <span class="nb">puts</span> <span class="n">result</span>
<span class="k">end</span>
</pre>
<p>Now you can combine all this to get a nice shorthand:</p>
<pre class="code ruby literal-block">
<span class="k">def</span> <span class="nf">myotherfunc</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">try</span> <span class="n">myotherfunc</span> <span class="n">a</span>
<span class="k">end</span>
</pre>
<p>The compiler would basically desugar that into:</p>
<pre class="code ruby literal-block">
<span class="k">def</span> <span class="nf">myotherfunc</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
  <span class="k">return</span>
    <span class="n">try</span>
      <span class="n">myotherfunc</span> <span class="n">a</span>
    <span class="n">except</span> <span class="no">MyErrorType</span> <span class="o">|</span> <span class="no">MyOtherErrorType</span> <span class="n">ex</span>
      <span class="k">raise</span> <span class="n">ex</span>
    <span class="k">else</span> <span class="n">value</span>
      <span class="n">value</span>
<span class="k">end</span>
</pre>
<p>As an added benefit, you can chain <tt class="docutils literal">!</tt> uses, so <tt class="docutils literal"><span class="pre">T![E1]![E2]</span></tt> would be
converted to <tt class="docutils literal"><span class="pre">T![E1,E2]</span></tt>. This seems useless, but it's very handy with generic
types.</p>
<p>I call all this:</p>
<p><strong>Imperative monads</strong></p>
</div>
<div class="section" id="differences-from-other-strategies">
<h2>Differences from other strategies</h2>
<ul class="simple">
<li>Exceptions are unchecked. On the other hand, with imperative monads, if you try
to use a function that can error in an expression, you'll get a type error (e.g.
<tt class="docutils literal">1 + myfunc(2)</tt>). In addition, if you forgot to handle an error type, you'll
still get a type error.</li>
<li>Unlike checked exceptions, imperative monads, when combined with type inference
as shown above, don't necessarily require you to write out every single possible
error. Callbacks would work as excepted, since errors are really just return
values with some added awesomeness.</li>
<li>Imperative monads have lots of sugar to handle errors, so it's as safe as Go (if
you can call it that...). In contrary to Elixir, imperative monads allow you to
create your own error types, just like Go or normal exceptions. You can encode
all the information you want into the type itself.</li>
<li>Union types can be a bit messy in imperative languages, but imperative monads
were designed exactly for that. They're not verbose, and it would be almost
impossible to end up with nested errors.</li>
</ul>
<p>Last but not least, since errors are again types, there's lots of room for
potential compiler optimizations.</p>
</div>
<div class="section" id="sequencing">
<h2>Sequencing</h2>
<p>This was actually not present in the original post, but someone pointed it out, so
I'm adding it here. (I actually can't believe I forgot this, considering this is
easily one of my error handling deal-breakers...)</p>
<p>What happens to error sequences? Exceptions are great for this:</p>
<pre class="code python literal-block">
<span class="k">try</span><span class="p">:</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">something</span><span class="p">()</span>
    <span class="n">something_else</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="k">except</span> <span class="ne">IOError</span><span class="p">:</span> <span class="c"># If any of the expressions result in an IOError.</span>
    <span class="k">print</span><span class="p">(</span><span class="s">'Error occurred!'</span><span class="p">)</span>
</pre>
<p>Well, that could go something like this:</p>
<pre class="code ruby literal-block">
<span class="n">try</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">try</span> <span class="n">something</span>
    <span class="n">something_else</span> <span class="n">x</span>
<span class="n">except</span> <span class="no">IOError</span> <span class="n">as</span> <span class="n">ex</span>
    <span class="nb">puts</span> <span class="s2">"Error occurred!"</span>
</pre>
<p>What exactly does this do?</p>
<p>The core idea is that, when <tt class="docutils literal">try</tt>'s are nested, errors propogate up. This code
does what you might expect; if <tt class="docutils literal">something</tt> returns an error type, it causes an
error. This error is then propogated up to the outer <tt class="docutils literal">try</tt>, which would forward
it to the <tt class="docutils literal">except</tt> block.</p>
</div>
<div class="section" id="issues">
<h2>Issues</h2>
<p>Honestly, the only issue I can think of is just with sequences and their
transformation functions. If you have a functional language, you'll need multiple
versions of every sequence function, like Haskell's <tt class="docutils literal">map</tt> vs <tt class="docutils literal">mapM</tt> and
<tt class="docutils literal">filter</tt> vs <tt class="docutils literal">filterM</tt>.</p>
</div>
    </div>
    <aside class="postpromonav">
    <nav>
    

    
        <ul class="pager">
            <li class="previous">
                <a href="a-tour-of-the-howl-programming-text-editor.html" rel="prev" title="A tour of the Howl programming text editor">Previous post</a>
            </li>
        </ul>

    </nav>
    </aside>
        <section class="comments">
        <h2>Comments</h2>
        
        
        <div id="disqus_thread"></div>
        <script>
        var disqus_shortname ="blockbyte",
            disqus_url="http://kirbyfan64.github.io/posts/an-idea-for-concise-checked-error-handling-in-imperative-languages.html",
        disqus_title="An idea for concise, checked error handling in imperative languages",
        disqus_identifier="cache/posts/an-idea-for-concise-checked-error-handling-in-imperative-languages.html",
        disqus_config = function () {
            this.language = "en";
        };
        (function() {
            var dsq = document.createElement('script'); dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a>
</noscript>
    <a href="//disqus.com" class="dsq-brlink" rel="nofollow">Comments powered by <span class="logo-disqus">Disqus</span></a>


        </section>
    

</article>

        
       <script>var disqus_shortname="blockbyte";(function(){var a=document.createElement("script");a.async=true;a.src="//"+disqus_shortname+".disqus.com/count.js";(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(a)}());</script>



        </div>
        <!--End of body content-->

        <footer>
            Contents © 2016         <a href="mailto:rymg19@gmail.com">Ryan Gonzalez</a> - Powered by         <a href="http://getnikola.com" rel="nofollow">Nikola</a>         
            
        </footer>
    </div>
</div>


            <script src="../assets/js/all-nocdn.js"></script>
    
<!-- Social buttons -->
<div id="addthisbox" class="addthis_toolbox addthis_peekaboo_style addthis_default_style addthis_label_style addthis_32x32_style">
<a class="addthis_button_more">Share</a>
<ul>
<li>
<a class="addthis_button_facebook"></a>
</li>
<li>
<a class="addthis_button_google_plusone_share"></a>
</li>
<li>
<a class="addthis_button_linkedin"></a>
</li>
<li>
<a class="addthis_button_twitter"></a>
</li>
</ul>
</div>
<script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-4f7088a56bb93798"></script>
<!-- End of social buttons -->


    <script>jQuery("a.image-reference").colorbox({rel:"gal",maxWidth:"100%",maxHeight:"100%",scalePhotos:true});</script>
    
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-55018880-1', 'auto');
  ga('send', 'pageview');

</script>

</body>
</html>
