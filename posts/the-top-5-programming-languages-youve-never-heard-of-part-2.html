<!DOCTYPE html>

<head>
  <title>The top 5 programming languages you've never heard of (part 2)</title>
  <script defer src="/dist/pack.js"></script>
  <link rel="stylesheet" href="/dist/pack.css">
  <script defer type="application/dart" src="../page.initialize.dart"></script>
  <script defer src="packages/browser/dart.js"></script>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>

<body >
  <div id="page" v-cloak>
    <site-navbar></site-navbar>
    <site-title created-on="2015-03-08 17:04"></site-title>

    <div id="teaser">
      <p>
        Yesterday, I wrote a post about
        <a href="/posts/the-top-5-programming-languages-youve-never-heard-of.html">
          the top 5 programming languages you've never heard of</a>.
        Well, since it was kind of short (I didn't have too much time to write), I'm
        going to put a little more info here.</p>
    </div>

    <link-header id="nim">Nim</link-header>

    <p>
      I enjoy coding in <a href="http://nim-lang.org/">Nim</a> because it's fun.
      Nim's goal is seemingly to blur the line between compiled and scripting
      languages, and it's doing a GREAT job. The compiler is self-hosting, but it's
      not quite the prime example of a well-written Nim program (it was ported from
      Object Pascal). A better example is Nimble: the Nim package manager. Here's a
      piece of Nimble's source code:</p>

    <div class="highlight"><pre><span></span><span class="k">proc </span><span class="nf">update</span><span class="p">(</span><span class="n">options</span><span class="p">:</span> <span class="n">Options</span><span class="p">)</span> <span class="o">=</span>
  <span class="sd">## Downloads the package list from the specified URL.</span>
  <span class="sd">##</span>
  <span class="sd">## If the download is successful, the global didUpdatePackages is set to</span>
  <span class="sd">## true. Otherwise an exception is raised on error.</span>
  <span class="k">let</span> <span class="n">url</span> <span class="o">=</span>
    <span class="k">if</span> <span class="n">options</span><span class="p">.</span><span class="n">action</span><span class="p">.</span><span class="n">typ</span> <span class="o">==</span> <span class="n">actionUpdate</span> <span class="ow">and</span> <span class="n">options</span><span class="p">.</span><span class="n">action</span><span class="p">.</span><span class="n">optionalURL</span> <span class="o">!=</span> <span class="s">&quot;&quot;</span><span class="p">:</span>
      <span class="n">options</span><span class="p">.</span><span class="n">action</span><span class="p">.</span><span class="n">optionalURL</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">defaultPackageURL</span>
  <span class="n">echo</span><span class="p">(</span><span class="s">&quot;Downloading package list from &quot;</span> <span class="o">&amp;</span> <span class="n">url</span><span class="p">)</span>
  <span class="n">downloadFile</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="n">options</span><span class="p">.</span><span class="n">getNimbleDir</span><span class="p">()</span> <span class="o">/</span> <span class="s">&quot;packages.json&quot;</span><span class="p">)</span>
  <span class="n">echo</span><span class="p">(</span><span class="s">&quot;Done.&quot;</span><span class="p">)</span>
    
</pre></div>


    <p>A longer piece:</p>

    <div class="highlight"><pre><span></span><span class="k">proc </span><span class="nf">parseConfig</span><span class="o">*</span><span class="p">():</span> <span class="n">Config</span> <span class="o">=</span>
  <span class="n">result</span> <span class="o">=</span> <span class="n">initConfig</span><span class="p">()</span>
  <span class="kd">var</span> <span class="n">confFile</span> <span class="o">=</span> <span class="n">getConfigDir</span><span class="p">()</span> <span class="o">/</span> <span class="s">&quot;nimble&quot;</span> <span class="o">/</span> <span class="s">&quot;nimble.ini&quot;</span>

  <span class="kd">var</span> <span class="n">f</span> <span class="o">=</span> <span class="n">newFileStream</span><span class="p">(</span><span class="n">confFile</span><span class="p">,</span> <span class="n">fmRead</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">f</span> <span class="o">==</span> <span class="kp">nil</span><span class="p">:</span>
    <span class="c"># Try the old deprecated babel.ini</span>
    <span class="n">confFile</span> <span class="o">=</span> <span class="n">getConfigDir</span><span class="p">()</span> <span class="o">/</span> <span class="s">&quot;babel&quot;</span> <span class="o">/</span> <span class="s">&quot;babel.ini&quot;</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">newFileStream</span><span class="p">(</span><span class="n">confFile</span><span class="p">,</span> <span class="n">fmRead</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">f</span> <span class="o">!=</span> <span class="kp">nil</span><span class="p">:</span>
      <span class="n">echo</span><span class="p">(</span><span class="s">&quot;[Warning] Using deprecated config file at &quot;</span><span class="p">,</span> <span class="n">confFile</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">f</span> <span class="o">!=</span> <span class="kp">nil</span><span class="p">:</span>
    <span class="n">echo</span><span class="p">(</span><span class="s">&quot;Reading from config file at &quot;</span><span class="p">,</span> <span class="n">confFile</span><span class="p">)</span>
    <span class="kd">var</span> <span class="n">p</span><span class="p">:</span> <span class="n">CfgParser</span>
    <span class="n">open</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">confFile</span><span class="p">)</span>
    <span class="k">while</span> <span class="kp">true</span><span class="p">:</span>
      <span class="kd">var</span> <span class="n">e</span> <span class="o">=</span> <span class="n">next</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
      <span class="k">case</span> <span class="n">e</span><span class="p">.</span><span class="n">kind</span>
      <span class="k">of</span> <span class="n">cfgEof</span><span class="p">:</span>
        <span class="k">break</span>
      <span class="k">of</span> <span class="n">cfgSectionStart</span><span class="p">:</span> <span class="k">discard</span>
      <span class="k">of</span> <span class="n">cfgKeyValuePair</span><span class="p">,</span> <span class="n">cfgOption</span><span class="p">:</span>
        <span class="k">case</span> <span class="n">e</span><span class="p">.</span><span class="n">key</span><span class="p">.</span><span class="n">normalize</span>
        <span class="k">of</span> <span class="s">&quot;nimbledir&quot;</span><span class="p">:</span>
          <span class="c"># Ensure we don&#39;t restore the deprecated nimble dir.</span>
          <span class="k">if</span> <span class="n">e</span><span class="p">.</span><span class="n">value</span> <span class="o">!=</span> <span class="n">getHomeDir</span><span class="p">()</span> <span class="o">/</span> <span class="s">&quot;.babel&quot;</span><span class="p">:</span>
            <span class="n">result</span><span class="p">.</span><span class="n">nimbleDir</span> <span class="o">=</span> <span class="n">e</span><span class="p">.</span><span class="n">value</span>
        <span class="k">of</span> <span class="s">&quot;chcp&quot;</span><span class="p">:</span>
          <span class="n">result</span><span class="p">.</span><span class="n">chcp</span> <span class="o">=</span> <span class="n">parseBool</span><span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">value</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="k">raise</span> <span class="n">newException</span><span class="p">(</span><span class="n">NimbleError</span><span class="p">,</span> <span class="s">&quot;Unable to parse config file:&quot;</span> <span class="o">&amp;</span>
                                  <span class="s">&quot; Unknown key: &quot;</span> <span class="o">&amp;</span> <span class="n">e</span><span class="p">.</span><span class="n">key</span><span class="p">)</span>
      <span class="k">of</span> <span class="n">cfgError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">newException</span><span class="p">(</span><span class="n">NimbleError</span><span class="p">,</span> <span class="s">&quot;Unable to parse config file: &quot;</span> <span class="o">&amp;</span> <span class="n">e</span><span class="p">.</span><span class="n">msg</span><span class="p">)</span>
    <span class="n">close</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    
</pre></div>


    <link-header id="felix">Felix</link-header>

    <p>
      <a href="http://felix-lang.org/">Felix</a> is unique. It's a mix of C++, ML,
      and lots of unique ideas. Here's a nice sample from a toy JSON parser I was
      writing (this is only the lexer part):</p>

    <div class="highlight"><pre><span></span>class JSON {
    typedef LineType = int;

    union Value =
        | Object of strdict[Value]
        | Array  of list[Value]
        | String of string
        | Number of double
        | True
        | False
        | Null
        | Error of string * LineType
    ;

    union Token =
        | TString of string
        | TNumber of double
        | TLBrace // {
        | TRBrace // }
        | TLBrak  // [
        | TRBrak  // ]
        | TColon  // :
        | TTrue   // true
        | TFalse  // false
        | TNull   // null
        | TEOF
        | TError of string * LineType
    ;

    instance Str[Token] {
        fun str(t: Token) =&gt; match t with
            | TString ?s =&gt; &quot;TString \&quot;&quot; + s + &quot;\&quot;&quot;
            | TNumber ?n =&gt; &quot;TNumber &quot; + n.str
            | TLBrace    =&gt; &quot;TLBrace&quot;
            | TRBrace    =&gt; &quot;TRBrace&quot;
            | TLBrak     =&gt; &quot;TLBrak&quot;
            | TRBrak     =&gt; &quot;TRBrak&quot;
            | TColon     =&gt; &quot;TColon&quot;
            | TTrue      =&gt; &quot;TTrue&quot;
            | TFalse     =&gt; &quot;TFalse&quot;
            | TNull      =&gt; &quot;TNull&quot;
            | TEOF       =&gt; &quot;TEOF&quot;
            | TError (?s, ?i) =&gt; &quot;error at line &quot; + i.str + &quot;: &quot; + s
        endmatch;
    }

    proc lex(s: string, line: &amp;LineType, outs: oschannel[Token]) = {
        line &lt;- 1;

        proc tok(t: Token) =&gt; write $ outs, t;

        proc err(s: string) = {
            tok $ TError(s, *line);
            return from lex;
        };

        var i = 0.size;

        while i &lt; s.len do
            while s.[i].isspace do
                if s.[i] == &quot;\n&quot; do *line++; done;
                i++;
                if i &gt;= s.len goto eof;
            done;

            // number
            if s.[i].isnumeric or (i+1 &lt; s.len and s.[i] == &quot;-&quot; and
                                     s.[i+1].isnumeric) do
                d := s.[i to].double;
                i += d.str.len;
                tok $ TNumber d;
            // string
            elif s.[i] == &quot;\&quot;&quot; do
                i++;
                var st = &quot;&quot;;
                while i &lt; s.len and s.[i] != &quot;\n&quot; and s.[i] != &quot;\&quot;&quot; do
                    st += s.[i];
                    i++;
                done;
                if s.[i] != &quot;\&quot;&quot; call err &quot;unterminated string literal&quot;;
                i++;
                tok $ TString st;
            // literals
            elif s.[i to i+4] == &quot;true&quot; do
                tok $ TTrue;
                i += 4.size;
            elif s.[i to i+5] == &quot;false&quot; do
                tok $ TFalse;
                i += 5.size;
            elif s.[i to i+4] == &quot;null&quot; do
                tok $ TNull;
                i += 4.size;
            // others
            else
                match s.[i].str with
                    | &quot;{&quot; =&gt; tok TLBrace;
                    | &quot;}&quot; =&gt; tok TRBrace;
                    | &quot;[&quot; =&gt; tok TLBrak;
                    | &quot;]&quot; =&gt; tok TRBrak;
                    | &quot;:&quot; =&gt; tok TColon;
                    | _   =&gt; err &quot;unknown token&quot;;
                endmatch;

                i++;
            done;
        done;

        eof:&gt;
        tok TEOF;
    }
}
    
</pre></div>


    <p>
      <a href="http://felix-lang.org/%24/usr/local/lib/felix/felix-latest//share/lib/web/json.flx">
        Here's</a> a link to Felix's own JSON parser, which is written more nicely
        than mine is...</p>

    <p>
      It illustrates some nice features, such as schannels (coroutines on steroids).
      schannels are like Go's channels, but not concurrent. Felix has another Go-like
      channel named fchannels, which are concurrent.</p>

    <p>
      Felix also has a nice set of utilities (a web server, a literate programming
      format, an
      <a href="https://github.com/felix-lang/felix/blob/master/src/tools/flx_config.fdoc">
        alpha-quality</a> graphical config tool) and a decently-sized standard
        library.</p>

    <p>
      Cons? Very little documentation. However, the mailing list is very
      responsive.</p>

    <link-header id="myrddin">Myrddin</link-header>

    <p>
      <a href="http://eigenstate.org/myrddin/">Myrddin</a> is essentially how C
      would probably look if it were designed right now. Some features:</p>

    <ul>
      <li>Type inference</li>
      <li>Pattern matching</li>
      <li>Go-style slices</li>
      <li>C-style memory management</li>
    </ul>

    <p>
      All in a C-style language. I've been toying with writing a kernel in it, and
      it's been going very well. I have a lot of hope in Myrddin.</p>

    <p>
      A great example is the
      <a href="http://git.eigenstate.org/ori/libbio.git/tree/bio.myr">libbio</a>
      input/output library. Here's a snippet:</p>

    <div class="highlight"><pre><span></span>/*
writes to as much from `src` as possible to a file,
returning the number of bytes written.
*/
const write = {f, src
    std.assert(f.mode &amp; Wr != 0, &quot;File is not in write mode&quot;)
    /*
    Tack small writes onto the buffer end. Big ones
    flush the buffer and then go right to kernel.
    */
    if src.len &lt; (f.wbuf.len - f.wend)
        std.slcp(f.wbuf[f.wend:f.wend+src.len], src)
        f.wend += src.len
        -&gt; src.len
    else
        flush(f)
        -&gt; writebuf(f.fd, src)
    ;;
}
    
</pre></div>


    <p>
      However, the compiler generates VERY slow x64 assembly code at the
      moment...and only x64 assembly code. I'm working on a C backend, though, but
      it'll be a while until it's finished.</p>

    <link-header id="k">K</link-header>

    <p>
      <a href="http://www.kuro5hin.org/story/2002/11/14/22741/791">K</a>, along with
      <a href="http://kona.github.io/">Kona</a> (an open-source K implementation
      with bad error messages) is special. It's the result of shoving APL into an
      ASCII-character world.</p>

    <p>
      Here are some of the idioms at the
      <a href="https://github.com/kevinlawler/kona/wiki/Idioms">Kona wiki</a>:</p>

    <div class="highlight"><pre><span></span>shuffle:{x@&lt;&gt;(#x)#1 0} / Perfect shuffle
mean:{(+/x)%#x} / Arithmetic mean
fac:*/1+!: / Factorial
fib:{x{x,+/-2#x}/!2} / Fibonacci
life:{|/(1;x)&amp;3 4=\:+/,/2{-1 0 1!&#39;\:x}/x} / Conway&#39;s Game of Life
sort:{x@&lt;x} / Sort list
powerset:{x[&amp;:&#39;!2+&amp;#x]} / Powerset
    
</pre></div>


    <p>
      As you can see, K is very concise. A little too concise. However, as an
      array-processing language, it's great for iterating over large sequences of
      data, as <a href="http://kx.com/">kdb+</a> has shown. It's also very fast and
      lean (I'm speaking for kdb+, though, not Kona).</p>

    <p>
      If you can't already tell, the main con is that no one that doesn't know K
      will be able to read your programs without getting a seizure.</p>

    <link-header id="objeck">Objeck</link-header>

    <p>
      As I said before, <a href="http://www.objeck.org/">Objeck</a> is kind of like
      I envisioned Java to be, other than the (painful) lack of generics.</p>

    <p>It's pretty expressive and nice to work with:</p>

    <div class="highlight"><pre><span></span>class Factorial {
    function : native : Factorial(n : Int) ~ Int {
        if (n &lt;= 1) {
            return n;
        } else {
            return n * Factorial(n-1);
        };
    }

    function : Main(args : String[]) ~ Nil {
        &quot;Number: &quot;-&gt;Print();
        number := IO.Console-&gt;ReadString()-&gt;ToInt();
        if (number &lt; 0) {
            &quot;Number must be greater than 0&quot;-&gt;PrintLine();
            Runtime-&gt;Exit(1);
        };
        Factorial(number)-&gt;PrintLine();
    }
}
    
</pre></div>


    <p>
      It's very Java-esque but nicer to use. The cons would be the fact that there
      is <i>no true native compiler</i>. Sure, there's a "compiler", but it's like
      the Java compiler: it compiles to a bytecode that's executed by a VM. It
      Objeck's case, the VM is <code>obe</code>. You also have to manually specify
      that a function is native for it to be compiled to machine code. There also
      seem to be no unsigned types or operator overloading. Again.</p>

    <link-header id="others">Others</link-header>

    <p>
      Two honorable, discontinued mentions are
      <a href="https://code.google.com/p/anic/">ani</a> and
      <a href="http://www.alorelang.org/">Alore</a>.</p>

    <p>
      Ani is a programming language that would have sported implicit parallelism and
      very nice speed. Note that I said <i>would have</i>. A working compiler was
      never fully completed and the maintainer disappeared, so this language may
      never quite see the light of day. The
      <a href="https://groups.google.com/forum/#!forum/ani-compiler">
        project mailing list</a> is still there, though, so there are hopes that
      someday, someone may indeed restart the project.</p>

    <p>
      Alore was a language based on the ability to freely mix static and dynamic
      typing. Although it was a great idea, the language itself seemingly never
      caught on, and it was abandoned in favor of
      <a href="http://www.mypy-lang.org/">mypy</a>, a project with the same basic
      idea but implemented as a static type checker for Python.</p>

    <link-header id="summary">Summary</link-header>

    <p>
      That's all! As I said before, I hope one of the languages mentioned caught
      your eye.</p>

    <site-tags tags="compilers, felix, k, language, myrddin, nim, objeck, programming">
    </site-tags>
    <site-suffix></site-suffix>
  </div>
</body>
